import * as i0 from '@angular/core';
import { inject, ViewContainerRef, Directive, Component, ChangeDetectionStrategy, InjectionToken, Inject, Optional, Self, Input, NgModule } from '@angular/core';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import { fromEvent, Subject, EMPTY, merge, NEVER } from 'rxjs';
import { tap, shareReplay, distinctUntilChanged, switchMap, startWith, mapTo, takeUntil } from 'rxjs/operators';
import * as i3 from '@angular/forms';

class ControlErrorAnchorDirective {
    constructor() {
        this.vcr = inject(ViewContainerRef);
    }
}
ControlErrorAnchorDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: ControlErrorAnchorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
ControlErrorAnchorDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.0.1", type: ControlErrorAnchorDirective, isStandalone: true, selector: "[controlErrorAnchor]", exportAs: ["controlErrorAnchor"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: ControlErrorAnchorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[controlErrorAnchor]',
                    standalone: true,
                    exportAs: 'controlErrorAnchor'
                }]
        }] });

class DefaultControlErrorComponent {
    constructor(cdr, host) {
        this.cdr = cdr;
        this.host = host;
        this.errorText = null;
        this.hideError = true;
        this._addClasses = [];
    }
    createTemplate(tpl, error, text) {
        this.errorTemplate = tpl;
        this.errorContext = { $implicit: error, text };
        this.cdr.markForCheck();
    }
    set customClass(classes) {
        if (!this.hideError) {
            this._addClasses = Array.isArray(classes) ? classes : classes.split(/\s/);
            this.host.nativeElement.classList.add(...this._addClasses);
        }
    }
    set text(value) {
        if (value !== this.errorText) {
            this.errorText = value;
            this.hideError = !value;
            if (this.hideError) {
                this.host.nativeElement.classList.remove(...this._addClasses);
            }
            this.cdr.markForCheck();
        }
    }
}
DefaultControlErrorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: DefaultControlErrorComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
DefaultControlErrorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.1", type: DefaultControlErrorComponent, isStandalone: true, selector: "control-error", ngImport: i0, template: `
    <label class="control-error" [class.hide-control]="hideError" *ngIf="!errorTemplate">{{ errorText }}</label>
    <ng-template *ngTemplateOutlet="errorTemplate; context: errorContext"></ng-template>
  `, isInline: true, styles: [".hide-control{display:none!important}:host{display:block}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: DefaultControlErrorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'control-error', standalone: true, imports: [CommonModule], template: `
    <label class="control-error" [class.hide-control]="hideError" *ngIf="!errorTemplate">{{ errorText }}</label>
    <ng-template *ngTemplateOutlet="errorTemplate; context: errorContext"></ng-template>
  `, changeDetection: ChangeDetectionStrategy.OnPush, styles: [".hide-control{display:none!important}:host{display:block}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; } });

const FORM_ERRORS = new InjectionToken('FORM_ERRORS', {
    providedIn: 'root',
    factory: () => {
        return {};
    }
});
const ErrorTailorConfigProvider = new InjectionToken('ErrorTailorConfigProvider');

class FormActionDirective {
    constructor(host) {
        this.host = host;
        this.submit$ = fromEvent(this.element, 'submit').pipe(tap(() => {
            if (this.element.classList.contains('form-submitted') === false) {
                this.element.classList.add('form-submitted');
            }
        }), shareReplay({ refCount: true, bufferSize: 1 }));
        this.reset$ = fromEvent(this.element, 'reset').pipe(tap(() => {
            this.element.classList.remove('form-submitted');
        }), shareReplay({ refCount: true, bufferSize: 1 }));
    }
    get element() {
        return this.host.nativeElement;
    }
}
FormActionDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: FormActionDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
FormActionDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.0.1", type: FormActionDirective, isStandalone: true, selector: "form[errorTailor]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: FormActionDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: 'form[errorTailor]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

class ControlErrorsDirective {
    constructor(vcr, host, config, globalErrors, controlErrorAnchorParent, form, ngControl, controlContainer) {
        this.vcr = vcr;
        this.host = host;
        this.config = config;
        this.globalErrors = globalErrors;
        this.controlErrorAnchorParent = controlErrorAnchorParent;
        this.form = form;
        this.ngControl = ngControl;
        this.controlContainer = controlContainer;
        this.customErrors = {};
        this.destroy = new Subject();
        this.showError$ = new Subject();
        this.mergedConfig = {};
        this.submit$ = this.form ? this.form.submit$ : EMPTY;
        this.reset$ = this.form ? this.form.reset$ : EMPTY;
    }
    ngOnInit() {
        this.mergedConfig = this.buildConfig();
        this.anchor = this.resolveAnchor();
        this.control = (this.controlContainer || this.ngControl).control;
        const hasAsyncValidator = !!this.control.asyncValidator;
        const statusChanges$ = this.control.statusChanges.pipe(distinctUntilChanged());
        const valueChanges$ = this.control.valueChanges;
        const controlChanges$ = merge(statusChanges$, valueChanges$);
        let changesOnAsync$ = EMPTY;
        let changesOnBlur$ = EMPTY;
        let changesOnChange$ = EMPTY;
        if (!this.controlErrorsClass || this.controlErrorsClass?.length === 0) {
            if (this.mergedConfig.controlErrorsClass && this.mergedConfig.controlErrorsClass) {
                this.controlErrorsClass = this.mergedConfig.controlErrorsClass;
            }
        }
        if (!this.controlCustomClass || this.controlCustomClass?.length === 0) {
            if (this.mergedConfig.controlCustomClass && this.mergedConfig.controlCustomClass) {
                this.controlCustomClass = this.mergedConfig.controlCustomClass;
            }
        }
        if (this.mergedConfig.controlErrorsOn.async && hasAsyncValidator) {
            // hasAsyncThenUponStatusChange
            changesOnAsync$ = statusChanges$;
        }
        if (this.isInput && this.mergedConfig.controlErrorsOn.change) {
            // on each change
            changesOnChange$ = valueChanges$;
        }
        if (this.isInput && this.mergedConfig.controlErrorsOn.blur) {
            const blur$ = fromEvent(this.host.nativeElement, 'focusout');
            // blurFirstThenUponChange
            changesOnBlur$ = blur$.pipe(switchMap(() => valueChanges$.pipe(startWith(true))));
        }
        const submit$ = merge(this.submit$.pipe(mapTo(true)), this.reset$.pipe(mapTo(false)));
        // when submitted, submitFirstThenUponChanges
        const changesOnSubmit$ = submit$.pipe(switchMap(submit => (submit ? controlChanges$.pipe(startWith(true)) : NEVER)));
        // on reset, clear ComponentRef and customAnchorDestroyFn
        this.reset$.pipe(takeUntil(this.destroy)).subscribe(() => this.clearRefs());
        merge(changesOnAsync$, changesOnBlur$, changesOnChange$, changesOnSubmit$, this.showError$)
            .pipe(takeUntil(this.destroy))
            .subscribe(() => this.valueChanges());
    }
    setError(text, error) {
        if (!this.ref) {
            this.ref = this.anchor.createComponent(this.mergedConfig.controlErrorComponent);
        }
        const instance = this.ref.instance;
        if (this.controlErrorsTpl) {
            instance.createTemplate(this.controlErrorsTpl, error, text);
        }
        else {
            instance.text = text;
        }
        if (this.controlErrorsClass) {
            instance.customClass = this.controlErrorsClass;
        }
        if (!this.controlErrorAnchor && this.mergedConfig.controlErrorComponentAnchorFn) {
            this.customAnchorDestroyFn = this.mergedConfig.controlErrorComponentAnchorFn(this.host.nativeElement, this.ref.hostView.rootNodes[0]);
        }
    }
    /**
     * Explicit showing of a control error via some custom application code.
     */
    showError() {
        this.showError$.next();
    }
    /**
     * Explicit hiding of a control error via some custom application code.
     */
    hideError() {
        this.setError(null);
    }
    ngOnDestroy() {
        this.destroy.next();
        this.clearRefs();
    }
    get isInput() {
        return this.mergedConfig.blurPredicate(this.host.nativeElement);
    }
    clearRefs() {
        if (this.customAnchorDestroyFn) {
            this.customAnchorDestroyFn();
            this.customAnchorDestroyFn = null;
        }
        if (this.ref) {
            this.ref.destroy();
        }
        this.ref = null;
    }
    valueChanges() {
        const controlErrors = this.control.errors;
        const classesAdd = Array.isArray(this.controlCustomClass)
            ? this.controlCustomClass
            : this.controlCustomClass?.split(/\s/) ?? [];
        if (controlErrors) {
            const [firstKey] = Object.keys(controlErrors);
            const getError = this.customErrors[firstKey] || this.globalErrors[firstKey];
            if (!getError) {
                return;
            }
            const text = typeof getError === 'function' ? getError(controlErrors[firstKey]) : getError;
            if (this.isInput) {
                this.host.nativeElement.parentElement.classList.add('error-tailor-has-error');
                if (this.controlCustomClass) {
                    this.host.nativeElement.classList.add(...classesAdd);
                }
            }
            this.setError(text, controlErrors);
        }
        else if (this.ref) {
            if (this.isInput) {
                this.host.nativeElement.parentElement.classList.remove('error-tailor-has-error');
                if (this.controlCustomClass) {
                    this.host.nativeElement.classList.remove(...classesAdd);
                }
            }
            this.setError(null);
        }
    }
    resolveAnchor() {
        if (this.controlErrorAnchor) {
            return this.controlErrorAnchor.vcr;
        }
        if (this.controlErrorAnchorParent) {
            return this.controlErrorAnchorParent.vcr;
        }
        return this.vcr;
    }
    buildConfig() {
        return {
            ...{
                blurPredicate(element) {
                    return element.tagName === 'INPUT' || element.tagName === 'SELECT';
                },
                controlErrorComponent: DefaultControlErrorComponent
            },
            ...this.config,
            controlErrorsOn: {
                async: this.controlErrorsOnAsync ?? this.config.controlErrorsOn?.async ?? true,
                blur: this.controlErrorsOnBlur ?? this.config.controlErrorsOn?.blur ?? true,
                change: this.controlErrorsOnChange ?? this.config.controlErrorsOn?.change ?? false
            }
        };
    }
}
ControlErrorsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: ControlErrorsDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.ElementRef }, { token: ErrorTailorConfigProvider }, { token: FORM_ERRORS }, { token: ControlErrorAnchorDirective, optional: true }, { token: FormActionDirective, optional: true }, { token: i3.NgControl, optional: true, self: true }, { token: i3.ControlContainer, optional: true, self: true }], target: i0.ɵɵFactoryTarget.Directive });
ControlErrorsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.0.1", type: ControlErrorsDirective, isStandalone: true, selector: "[formControlName]:not([controlErrorsIgnore]), [formControl]:not([controlErrorsIgnore]), [formGroup]:not([controlErrorsIgnore]), [formGroupName]:not([controlErrorsIgnore]), [formArrayName]:not([controlErrorsIgnore]), [ngModel]:not([controlErrorsIgnore])", inputs: { customErrors: ["controlErrors", "customErrors"], controlErrorsClass: "controlErrorsClass", controlCustomClass: "controlCustomClass", controlErrorsTpl: "controlErrorsTpl", controlErrorsOnAsync: "controlErrorsOnAsync", controlErrorsOnBlur: "controlErrorsOnBlur", controlErrorsOnChange: "controlErrorsOnChange", controlErrorAnchor: "controlErrorAnchor" }, exportAs: ["errorTailor"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: ControlErrorsDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[formControlName]:not([controlErrorsIgnore]), [formControl]:not([controlErrorsIgnore]), [formGroup]:not([controlErrorsIgnore]), [formGroupName]:not([controlErrorsIgnore]), [formArrayName]:not([controlErrorsIgnore]), [ngModel]:not([controlErrorsIgnore])',
                    exportAs: 'errorTailor'
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [ErrorTailorConfigProvider]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [FORM_ERRORS]
                }] }, { type: ControlErrorAnchorDirective, decorators: [{
                    type: Optional
                }] }, { type: FormActionDirective, decorators: [{
                    type: Optional
                }] }, { type: i3.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: i3.ControlContainer, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }]; }, propDecorators: { customErrors: [{
                type: Input,
                args: ['controlErrors']
            }], controlErrorsClass: [{
                type: Input
            }], controlCustomClass: [{
                type: Input
            }], controlErrorsTpl: [{
                type: Input
            }], controlErrorsOnAsync: [{
                type: Input
            }], controlErrorsOnBlur: [{
                type: Input
            }], controlErrorsOnChange: [{
                type: Input
            }], controlErrorAnchor: [{
                type: Input
            }] } });

const _errorTailorImports = [
    ControlErrorsDirective,
    ControlErrorAnchorDirective,
    DefaultControlErrorComponent,
    FormActionDirective
];
class errorTailorImports {
}
errorTailorImports.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: errorTailorImports, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
errorTailorImports.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.1", ngImport: i0, type: errorTailorImports, imports: [ControlErrorsDirective,
        ControlErrorAnchorDirective,
        DefaultControlErrorComponent,
        FormActionDirective], exports: [ControlErrorsDirective,
        ControlErrorAnchorDirective,
        DefaultControlErrorComponent,
        FormActionDirective] });
errorTailorImports.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: errorTailorImports, imports: [DefaultControlErrorComponent] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: errorTailorImports, decorators: [{
            type: NgModule,
            args: [{
                    imports: [_errorTailorImports],
                    exports: [_errorTailorImports]
                }]
        }] });
function provideErrorTailorConfig(config) {
    return [
        {
            provide: ErrorTailorConfigProvider,
            useValue: config
        },
        {
            provide: FORM_ERRORS,
            ...config.errors
        }
    ];
}

/*
 * Public API Surface of error-tailor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ControlErrorAnchorDirective, ControlErrorsDirective, DefaultControlErrorComponent, ErrorTailorConfigProvider, FORM_ERRORS, FormActionDirective, errorTailorImports, provideErrorTailorConfig };
//# sourceMappingURL=ngneat-error-tailor.mjs.map
